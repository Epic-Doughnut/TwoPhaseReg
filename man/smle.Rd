% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/smle.R
\name{smle}
\alias{smle}
\title{Performs efficient semiparametric estimation for regression models under general two-phase designs.}
\usage{
smle(Y = NULL, Delta = NULL, X = NULL, Z = NULL, W = NULL,
  Bspline_Z = NULL, data = NULL, hn_scale = 1, MAX_ITER = 2000,
  TOL = 1e-04, noSE = FALSE, model = "linear", verbose = FALSE)
}
\arguments{
\item{Y}{Specifies the column of the continuous, binary (\eqn{0} or \eqn{1}), or time-to-event outcomes. Subjects with missing values of \code{Y} are omitted from the analysis. This option is required.}

\item{Delta}{Specifies the column of the event indicators. This option is required when performing Cox proportional hazards regression.}

\item{X}{Specifies the columns of expensive covariates. Subjects with missing values of \code{X} are considered as those not selected in the second phase. This argument is required.}

\item{Z}{Specifies the columns of the inexpensive covariates that are potentially correlated with \code{X}. Subjects with missing values of \code{Z} are omitted from the analysis. This argument is optional.}

\item{W}{Specifies the columns of the inexpensive covariates that are independent of \code{X} given \code{Z}. Subjects with missing values of \code{W} are omitted from the analysis. This argument is optional.}

\item{Bspline_Z}{Specifies the columns of the B-spline basis. Subjects with missing values of \code{Bspline_Z} are omitted from the analysis. This argument is optional.}

\item{data}{Specifies the name of the dataset. This argument is required.}

\item{hn_scale}{Specifies the scale of the perturbation constant in the variance estimation. For example, if \code{hn_scale = 0.5}, then the perturbation constant is \eqn{0.5n^{-1/2}}, where \eqn{n} is the first-phase sample size in the analysis. The default value is \code{1}. This argument is optional, and is not needed when there is no \code{Z}.}

\item{MAX_ITER}{Specifies the maximum number of iterations in the EM algorithm. The default number is \code{2000}. This argument is optional.}

\item{TOL}{Specifies the convergence criterion in the EM algorithm. The default value is \code{1E-4}. This argument is optional.}

\item{noSE}{If \code{TRUE}, then the variances of the parameter estimators will not be estimated. The default value is \code{FALSE}. This argument is optional.}

\item{model}{Specifies the model. Possible values are "linear", "logistic", and "coxph". The default value is "linear".}

\item{verbose}{If \code{TRUE}, then show details of the analysis. The default value is \code{FALSE}.}
}
\value{
\item{coefficients}{Stores the analysis results.}
\item{convergence}{In parameter estimation, if the EM algorithm converges, then \code{convergence = TRUE}. Otherwise, \code{convergence = FALSE}.}
\item{convergence_var}{In variance estimation, if the EM algorithm converges, then \code{convergence_cov = TRUE}. Otherwise, \code{convergence_cov = FALSE}.}
}
\description{
Performs efficient semiparametric estimation for regression models under general two-phase designs.
}
\examples{
library(TwoPhaseReg)
n = 2000
n2 = 600
true_beta = 0.3
true_gamma = 0.4
true_eta = 0.5
seed = 12345
r = 0.3
N_SIEVE = 8

#### when Z is a scaler
set.seed(12345)
simW = runif(n)
U2 = runif(n)
simX = runif(n)
simZ = r*simX+U2
simY = true_beta*simX+true_gamma*simZ+true_eta*simW+rnorm(n)
order.simY = order(simY)
phase2.id = c(order.simY[1:(n2/2)], order.simY[(n-(n2/2)+1):n])
Bspline_Z = matrix(NA, nrow=n, ncol=N_SIEVE)
cut_z = cut(simZ, breaks=quantile(simZ, probs=seq(0, 1, 1/N_SIEVE)), include.lowest = TRUE)
for (i in 1:N_SIEVE)
{
    Bspline_Z[,i] = as.numeric(cut_z == names(table(cut_z))[i])
}
colnames(Bspline_Z) = paste("bs", 1:N_SIEVE, sep="")
dat = data.frame(Y=simY, X=simX, Z=simZ, W=simW, Bspline_Z)
dat[-phase2.id,"X"] = NA

res = smle(Y="Y", X="X", Z="Z", W="W", Bspline_Z=colnames(Bspline_Z), data=dat)
res

#### when Z is two-dimensional
library(splines)
set.seed(12345)
U1 = runif(n)
U2 = runif(n)
simX = runif(n)
simZ_1 = r*simX+U1
simZ_2 = r*simX+U2
simY = true_beta*simX+true_gamma*simZ_1+true_eta*simZ_2+rnorm(n)
order.simY = order(simY)
phase2.id = c(order.simY[1:(n2/2)], order.simY[(n-(n2/2)+1):n])
bs1 = bs(simZ_1, df=N_SIEVE, degree=1, Boundary.knots=range(simZ_1), intercept=TRUE)
bs2 = bs(simZ_2, df=N_SIEVE, degree=1, Boundary.knots=range(simZ_2), intercept=TRUE)
Bspline_Z = matrix(NA, ncol=N_SIEVE^2, nrow=n)
for (i in 1:ncol(bs1)) {
    for (j in 1:ncol(bs2)) {
        idx = i*N_SIEVE+j-N_SIEVE
        Bspline_Z[,idx] = bs1[,i]*bs2[,j]
    }
}
colnames(Bspline_Z) = paste("bs", 1:ncol(Bspline_Z), sep="")
dat = data.frame(Y=simY, X=simX, Z1=simZ_1, Z2=simZ_2, Bspline_Z)
dat[-phase2.id,"X"] = NA

res = smle(Y="Y", X="X", Z=c("Z1", "Z2"), Bspline_Z=colnames(Bspline_Z), data=dat)
res
}
\references{
Tao, R., Zeng, D., and Lin, D. Y. (2017). "Efficient Semiparametric Inference Under Two-Phase Sampling, with Applications to Genetic Association Studies", Journal of the American Statistical Association, in press.
}

